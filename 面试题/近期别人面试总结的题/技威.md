##### ;常见HTTP状态码 及其含义

1xx：信息状态码
2xx：请求成功
3xx：重定向
4xx：客户端错误
5xx：服务器错误 

200 OK                   			请求正常 

304 Not Modified          		自从上次请求后，请求的网页未修改过，有缓存。

404 Not Found             		没有找到对应页面

500 Internal Server Error 	服务器内部出现错误

##### rem   em

使用rem为元素设定字体大小时，是相对大小，相对的是<html>根元素。

比如html默认 font-size  16px，  1rem = 16px, 2rem = 32px

em 也是设置字体的相对大小，相对的是父元素。

对比em和rem：

| 单位 |             定义              |          特点          |
| :--- | :---------------------------: | :--------------------: |
| rem  | font size of the root element | 以根元素字体大小为基准 |
| em   |   font size of the element    | 以父元素字体大小为基准 |

##### 面向对象的三个特征及其含义

封装，继承，多态

##### 对HTML语义化的理解

常用的语义化标签包括 <header>头部  <nav>导航栏  <section>区块（有语义化的div）

<main>主要区域  <article>主要内容  <aside>侧边栏  <footer>底部

![img](https://qqadapt.qpic.cn/txdocpic/0/cc43aaaccbf0016515fdb9d4dc382a1d/0)



1. 在没有CSS样式的时候，依然能让页面呈现清晰的结构。
2. 有利于SEO：有助于爬虫抓取更多的有效信息：爬虫依赖于 标签 来确定上下文和各个关键字的权重。



##### 常见的内联元素、块级元素、空(void)元素有哪些？ 其中内联元素 块级元素的特征是什么

内联元素：不能独占一行，不能设置宽高。

span  input  a  button  img

块级元素：独占一行，可以设置宽高。

div  ul ol li  p  h1 dl dt

空(void)元素：

br  hr  img  link  meta

CSS中 display:none 和 visibility: hidden 的区别是什么

\1. 是否占据空间

visibility: hidden----将元素隐藏，但是在网页中该占的位置还是占着。

display: none----将元素的显示设为无，即在网页中不占任何的位置。



\2. 是否渲染

display:none，会触发reflow（回流），进行渲染。 

visibility:hidden，只会触发repaint（重绘），因为没有发现位置变化，不进行渲染。



\3. 是否为继承属性

display:none，display不是继承属性，元素及其子元素都会消失。 

visibility 具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来



\4. 读屏器是否读取

读屏器不会读取display：none的元素内容，而会读取visibility：hidden的元素内容。



##### 用原生JS写一个冒泡排序

##### Vue.js 和 JQuery 怎么交叉使用

##### 混合模式 和 前后端分离 的优缺点？对搜索引擎的友好性？

**前后端分离**：前端html页面 通过ajax 调用后端 api接口，并使用json数据进行交互。

优点：

前后端的逻辑不需要混合在一起，两端的开发人员基本不需要参与对方的代码，大大提升了整体的开发效率，出现bug也方便定位问题。



缺点：**主要是 seo 和 首屏渲染问题。**

1. 首屏如果有需要渲染数据的部分，要等到ajax请求数据返回后，才能完全展示。
2. 不利于搜索引擎优化。 因为国内的搜索引擎不解析js，前后端分离的网站只能抓取到模板文件，里面是没有数据的。



混合模式：

优点：

\1. 可以快速进行首屏展示，避免ajax请求所带来的渲染延时，用户体验好。

\2. 有利于seo搜索引擎优化。

\3. 在访问高峰期，可以将某些访问量大并且业务数据大部分不变的页面 生成静态页面进行缓存，有利于快速渲染。



缺点：

\1. 耦合度太高，在协作开发的时候，前端的开发人员要与后端的开发人员互相等待 来完成整体的功能，而且后端开发人员需要了解前端的页面结构，来填充逻辑代码，大大降低开发效率，并且一旦出问题无法快速定位问题。

\2. 不易维护，由于对于一个页面的维护，需要牵扯到两端的开发人员来共同进行维护，在需求变更后，容易出现bug。

##### Ajax

##### JSONP 是什么？ 有哪些跨域技术，原理是什么？同源政策

**同源政策：**

所谓同源是指，域名，协议，端口相同。

例如 <http://www.example.com/dir/page.html> 这个网址，

协议是 http://，域名是[www.example.com](http://www.example.com)，端口是80（默认端口可以省略）。



同源政策是浏览器的一个安全功能，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方资源。所以在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。



跨域技术：JSONP，CORS



**JSONP**  只支持GET请求

<script>标签 可以加载跨域资源，不受同源限制。

JSONP就是通过 动态创建script，src为请求的接口地址，请求一个 带参网址，实现跨域通信。



**CORS**  Cross-origin resource sharing



服务端设置Access-Control-Allow-Origin

##### CORS 怎么传数据

CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服

务器同意，指定Access-Control-Allow-Credentials字段 （后端）。



Access-Control-Allow-Credentials: true



另一方面，开发者必须在AJAX请求中设置**withCredentials**属性（前端）。



var xhr = new XMLHttpRequest();

xhr.withCredentials = true;

##### webpack 的作用

Webpack的作用：通过使用各种loaders plugins，编译浏览器不能直接识别的语法、文				

件，最后包为一个（或多个）浏览器可识别的 js 文件。

优点：模块化

在webpack看来一切都是模块，包括你的JavaScript代码，也包括CSS和fonts以及图片等，

只要通过合适的loaders，它们都可以被当做模块被处理。

$.extent( )   $.fn.extent( )



##### Vue 父子组件之间， 非父子组件之间如何通信传数据

父传子：通过属性绑定。

父组件通过属性绑定传值，子组件 在 props 中定义一下父组件传来的数据。



子传父：通过事件调用。

父组件定义方法，进行事件绑定。子组件用 this.$emit 触发父组件传来的方法，并在调用时传值给父组件。



非父子组件：vuex

性能优化的方式

##### let 和  var  的区别

var 变量声明

1. 作用域：该语句所在的**函数内**。
2. 变量提升：不论var声明的变量处于当前作用域的第几行，都会被提升到作用域的顶部，并初始化为undefined。



let 变量声明

1. 作用域：只在该声明语句所在的**代码块内**生效。
2. 临时性死区：在let声明的代码块作用域内，在声明变量 let a = xx; 之前，该变量都是不可用的，访问会报错。
3. 禁止重复声明：只要let作用域中已存在变量a，无论前一次是 let a 还是 var a，都不可以再重复声明 let a = xx;

##### ( ) => { }     fn ( ) { }   的区别

箭头函数

##### 解构 扩展 运算符

##### 原型链

##### 正则表达式（邮箱）