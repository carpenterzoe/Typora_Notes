#### 请用 es5 与 es6 分别封装一个数组去重的方法

##### ES5数组去重

最简便的数组去重：  temp.indexOf (array[ i ] ) == -1

```js
var aa = [1,2,2,4,9,6,7,5,5];

function uniq(array){
    var temp = []; //一个新的临时数组
    for(var i = 0; i < array.length; i++){
        if(temp.indexOf(array[i]) == -1){
            temp.push(array[i]);
        }
    }
    return temp;
}
console.log(uniq(aa));
```

利用对象特性去重

```js
var arr = [5, '5', 5, 2, '2', 2, 1, 3];

// 利用对象的特性，做数组去重
// var obj = {
//   5: 1,
//   "5": 2
// }
// console.log(obj);  // Object 5:2   key值 字符串或数字 是一样的

function unique(arr){
  var brr = [],
      obj = {};
  for( var i=0; i<arr.length; i++){

    // 利用对象，往数组 brr 添加值
    
    // 初始对象obj是空对象， 所以 obj[arr[i]] 全都是 undefined，布尔值 false
    // 所以 !obj[arr[i]] 为 true，就可以进到 if 里。
    
    // 进入 if 后的 obj[arr[i]] 都被赋值为 true，
    /// 所以下次再遇到同样的数字，外部for循环 !obj[arr[i]] = false 就进不来了第二次if语句了。
    
    if (!obj[arr[i]]){

      obj[arr[i]] = true;
      brr.push(arr[i]);
    
    }
  }
  return brr;
}
console.log(unique(arr));
```

##### ES6数组去重 new Set( );

ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。

缺点： 同值不同类型不能去除，如 数字 5 和 字符串 "5"

```js
var arr = [5, '5', 5, 2, '2', 2, 1, 3];
var set = new Set(arr);
console.log(set);
```

#### 封装一个对象深拷贝方法

