#### 请用 es5 与 es6 分别封装一个数组去重的方法

##### ES5数组去重

最简便的数组去重：  temp.indexOf (array[ i ] ) == -1

```js
var aa = [1,2,2,4,9,6,7,5,5];

function uniq(array){
    var temp = []; //一个新的临时数组
    for(var i = 0; i < array.length; i++){
        if(temp.indexOf(array[i]) == -1){
            temp.push(array[i]);
        }
    }
    return temp;
}
console.log(uniq(aa));
```

利用对象特性去重

```js
var arr = [5, '5', 5, 2, '2', 2, 1, 3];

// 利用对象的特性，做数组去重
// var obj = {
//   5: 1,
//   "5": 2
// }
// console.log(obj);  // Object 5:2   key值 字符串或数字 是一样的

function unique(arr){
  var brr = [],
      obj = {};
  for( var i=0; i<arr.length; i++){

    // 利用对象，往数组 brr 添加值
    
    // 初始对象obj是空对象， 所以 obj[arr[i]] 全都是 undefined，布尔值 false
    // 所以 !obj[arr[i]] 为 true，就可以进到 if 里。
    
    // 进入 if 后的 obj[arr[i]] 都被赋值为 true，
    /// 所以下次再遇到同样的数字，外部for循环 !obj[arr[i]] = false 就进不来了第二次if语句了。
    
    if (!obj[arr[i]]){

      obj[arr[i]] = true;
      brr.push(arr[i]);
    
    }
  }
  return brr;
}
console.log(unique(arr));
```

##### ES6数组去重 new Set( );

ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。

缺点： 同值不同类型不能去除，如 数字 5 和 字符串 "5"

```js
var arr = [5, '5', 5, 2, '2', 2, 1, 3];
var set = new Set(arr);
console.log(set);
```

#### 浅拷贝 深拷贝

https://www.cnblogs.com/echolun/p/7889848.html

浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组。新对象／数组只是原对象的一个引用。问题：一个改变，互相影响。

```js
var obj1 = {
  age: 18,
  arr: [1,2,3]
}

function copy(obj1){
  var obj2 = {}
  for(var k in obj1) {
    obj2[k] = obj1[k]
  }
  return obj2;
}

var obj2 = copy(obj1)
obj1.arr[0] = 'ooo'   // 浅拷贝 obj1的属性值发生变化，obj2也会变。
console.log(obj1, obj2);
```

##### 对象深拷贝

**深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”**。 解决：一个改变，互相不影响。

1. for ... in 循环，for(var k in obj1)，内部判断 区分要拷贝的是 object（引用类型，需要深拷贝） 还是 number 等 简单数据（直接赋值）。

   被拷贝的 obj1 是 'object'，就进行递归 深拷贝，不是就直接进入 else  简单赋值。（ [ ] { } 都是 object ） 

2. `(obj1[k].constructor == Array)? [] : {}`，以此初始化 obj2 为 [ ] 或 { }

3. `copy(obj1[k], obj2[k])`   递归 重复运行上面的，第二次传入的参是 obj1[k]，即 `for(var k in obj1) `循环的是 value 值 而不再是 key 值。 所以这次运行的是else里的简单赋值了。

```js
  var obj1 = {  // 原始对象
    age: 18,
    arr: [1,2,3]
  }
  
  var obj2 = {}  // 自己对象

  function copy(obj1, obj2){
    
    for(var k in obj1){
      if(typeof obj1[k] == 'object'){  // 只有对象引用类型才存在深拷贝浅拷贝

      obj2[k] = (obj1[k].constructor == Array)? []:{}

      copy(obj1[k], obj2[k])  // 递归第二层 运行的是value 不是key，所以会直接运行 else 部分，实现属性逐个拷贝。

      }else{      // 对于普通数值，一个改变不会引发另一个改变。所以这里分开处理。
        obj2[k] = obj1[k]   
      }
    }
    return obj2
  }

  var obj2 = copy(obj1, obj2)
  obj1.arr[0] = 'zhangsan'
  console.log(obj1.arr, obj2.arr)
```

