#### 构造函数 prototype constructor

https://blog.csdn.net/cc18868876837/article/details/81211729

##### 构造函数特点：

	1. 需要new实例化，内部使用this对象指向即将要生成的实例对象
 	2. 首字母大写，用于区分普通函数

```js
// 构造函数
function Foo(y) {
  // 构造函数将会以特定模式创建对象：被创建的对象都会有"y"属性
  this.y = y;
}
 
// "Foo.prototype"存放了新建对象的原型引用
// 所以我们可以将之用于定义继承和共享属性或方法
// 所以，和上例一样，我们有了如下代码：
 
// 继承属性"x"
Foo.prototype.x = 10;
 
// 继承方法"calculate"
Foo.prototype.calculate = function (z) {
  return this.x + this.y + z;
};
 
// 使用foo模式创建 "b" and "c"
var b = new Foo(20);
var c = new Foo(30);
 
// 调用继承的方法
b.calculate(30); // 60
c.calculate(40); // 80
 
// 让我们看看是否使用了预期的属性
 
console.log(
 
  // 每个实例对象都有__proto__属性，指向它的构造函数的 prototyppe
  
  b.__proto__ === Foo.prototype, // true
  c.__proto__ === Foo.prototype, // true
 
  // "Foo.prototype"自动创建了一个特殊的属性"constructor"
  // 指向a的构造函数本身

  // constructor默认指向 创建当前对象的构造函数。
  // 每一个对象实例都可以通过 constructor 访问它的构造函数。
 
  b.constructor === Foo, // true
  c.constructor === Foo, // true
  Foo.prototype.constructor === Foo // true  注意这里
  // 构造函数 prototype 原型的 constructor 指向 构造函数本身。
 
  b.calculate === b.__proto__.calculate, // true
  b.__proto__.calculate === Foo.prototype.calculate // true
 
);
```

①`__proto__`和`constructor`属性是**对象**所独有的；

② `prototype`属性是**函数**所独有的。

但是由于JS中函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性，这点是致使我们产生困惑的很大原因之一。

##### __ proto __ 属性  原型链

 __ proto __ 属性 由一个对象 指向它们的原型对象 （也可以理解为父对象）。

作用是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的 __ proto __ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往上找。

直到原型链顶端null（可以理解为原始人。。。），此时若还没找到，则返回undefined（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束）。

由以上这种通过 __ proto __ 属性来连接对象直到null的一条链即为我们所谓的原型链。

![img](https://img-blog.csdnimg.cn/20190311192013184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70)

##### constructor

constructor默认**指向**创建当前对象的**构造函数**。

每一个对象实例都可以通过 constructor 访问它的构造函数。

所有函数（此时看成对象了）最终的构造函数都指向**Function**。

```js
var f = new Foo();

alert(f.constructor === Foo);	// true
```

##### new一个实例对象的四个步骤

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象，因此，this就指向了这个新对象；
3. 执行构造函数中的代码，即为这个新对象添加属性、方法；
4. 返回新对象。 

```js
function Person(name,age,job) {
    this.name=name;
    this.age=age;
    this.job=job;
 }

var person1=new Person('zhy',18,'SoftWare Engineer');
var person2=new Person('zhy2',19,'Doctor');
```

